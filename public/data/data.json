{
	"python": {
		"words": [
			"if", "for", "remove", "add", "push", "pop", "class", "new", "list", "array",
			"elif", "break", "init", "sum", "enumerate", "def", "function", "select", "from", "else",
			"continue", "True", "False", "while", "any", "abs", "bool", "str", "set", "dict",
			"filter", "file", "range", "count", "round", "split", "input", "output", "comment", "comments",
			"syntax", "iteration", "random", "datetime", "async", "await", "map", "type", "object", "objects",
			"min", "max", "print", "console", "return", "item", "items", "event", "sort", "public",
			"private", "try", "catch", "python", "start", "session", "time", "append", "copy", "str",
			"loop", "timeout", "self", "not", "and", "pass"
		],
		"algorithms": [
			"def factorial(n):\n\tif n == 0:\n\t\treturn 1\n\telse:\n\t\treturn n * factorial(n-1)",
			"def reverse_string(s):\n\tstr_list = list(s)\n\tstart_index = 0\n\tend_index = len(s) - 1\n\twhile start_index < end_index:\n\t\tstr_list[start_index] = str_list[end_index]\n\t\tstr_list[end_index] = str_list[start_index]\n\t\tstart_index += 1\n\t\tend_index -= 1\n\treturn ''.join(str_list)",
			"def binary_search(arr, x):\n\tlow = 0\n\thigh = len(arr) - 1\n\tmid = 0\n\twhile low <= high:\n\t\tmid = (high + low) // 2\n\t\tif arr[mid] < x:\n\t\t\tlow = mid + 1\n\t\telif arr[mid] > x:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\treturn mid\n\treturn -1",
			"def bubble_sort(arr):\n\tn = len(arr)\n\tfor i in range(n):\n\t\tfor j in range(0, n-i-1):\n\t\t\tif arr[j] > arr[j+1]:\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]",
			"def quick_sort(arr):\n\tif len(arr) <= 1:\n\t\treturn arr\n\tpivot = arr[len(arr)//2]\n\tleft = [x for x in arr if x < pivot]\n\tmiddle = [x for x in arr if x == pivot]\n\tright = [x for x in arr if x > pivot]\n\treturn quick_sort(left) + middle + quick_sort(right)",
			"def binary_search(arr, x):\n\tlow = 0\n\thigh = len(arr) - 1\n\twhile low <= high:\n\t\tmid = (high + low) // 2\n\t\tif arr[mid] < x:\n\t\t\tlow = mid + 1\n\t\telif arr[mid] > x:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\treturn mid\n\treturn -1",
			"def longest_increasing_subsequence(arr):\n\tn = len(arr)\n\tlis = [1] * n\n\tfor i in range(1, n):\n\t\tfor j in range(0, i):\n\t\t\tif arr[i] > arr[j] and lis[i] < lis[j] + 1:\n\t\t\t\tlis[i] = lis[j] + 1\n\treturn max(lis)",
			"def longest_common_subsequence(X, Y):\n\tm = len(X)\n\tn = len(Y)\n\tL = [[None]*(n+1) for i in range(m+1)]\n\tfor i in range(m+1):\n\t\tfor j in range(n+1):\n\t\t\tif i == 0 or j == 0:\n\t\t\t\tL[i][j] = 0\n\t\t\telif X[i-1] == Y[j-1]:\n\t\t\t\tL[i][j] = L[i-1][j-1] + 1\n\t\t\telse:\n\t\t\t\tL[i][j] = max(L[i-1][j], L[i][j-1])\n\treturn L[m][n]",
			"def min_cost_path(cost, m, n):\n\tfor i in range(1, m+1):\n\t\tfor j in range(1, n+1):\n\t\t\tif i == 1 and j == 1:\n\t\t\t\tpass\n\t\t\telif i == 1:\n\t\t\t\tcost[i-1][j-1] += cost[i-1][j-2]\n\t\t\telif j == 1:\n\t\t\t\tcost[i-1][j-1] += cost[i-2][j-1]\n\t\t\telse:\n\t\t\t\tcost[i-1][j-1] += min(cost[i-2][j-1], cost[i-1][j-2])\n\treturn cost[m-1][n-1]",
			"def coin_change(coins, amount):\n\tif amount == 0:\n\t\treturn 0\n\tif amount < 0:\n\t\treturn float('inf')\n\tres = float('inf')\n\tfor coin in coins:\n\t\tsub_res = coin_change(coins, amount-coin)\n\t\tif sub_res != float('inf'):\n\t\t\tres = min(res, sub_res+1)\n\treturn res",
			"def knapSack(W, wt, val, n):\n\tif n == 0 or W == 0:\n\t\treturn 0\n\tif (wt[n-1] > W):\n\t\treturn knapSack(W, wt, val, n-1)\n\telse:\n\t\treturn max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \n\t\t\tknapSack(W, wt, val, n-1))",
			"def lps(str):\n\tn = len(str)\n\tL = [[0 for x in range(n)] for x in range(n)]\n\tfor i in range(n):\n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1):\n\t\tfor i in range(n-cl+1):\n\t\t\tj = i+cl-1\n\t\t\tif (str[i] == str[j] and cl == 2):\n\t\t\t\tL[i][j] = 2\n\t\t\telif (str[i] == str[j]):\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse:\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j])\n\treturn L[0][n-1]",
			"def is_multiple_of_three(n):\n\todd_count = 0\n\teven_count = 0\n\tif n < 0:\n\t\tn = -n\n\tif n == 0:\n\t\treturn True\n\tif n == 1:\n\t\treturn False\n\twhile n:\n\t\tif n & 1:\n\t\t\todd_count += 1\n\t\telse:\n\t\t\teven_count += 1\n\t\tn = n >> 1\n\treturn is_multiple_of_three(abs(odd_count - even_count))",
			"def fibonacci(n):\n\tif n == 0:\n\t\treturn 0\n\telif n == 1 or n == 2:\n\t\treturn 1\n\telse:\n\t\treturn fibonacci(n-1) + fibonacci(n-2)",
			"def multiply(a, b):\n\tif a == 0 or b == 0:\n\t\treturn 0\n\tif b > 0:\n\t\treturn a + multiply(a, b-1)\n\tif b < 0:\n\t\treturn -multiply(a, -b)",
			"def square_root(n):\n\tprecision = 0.00001\n\tx = n\n\twhile (x - n / x) > precision:\n\t\tx = (x + n / x) / 2\n\treturn x",
			"def sieve_of_eratosthenes(n):\n\tprime = [True for i in range(n+1)]\n\tp = 2\n\twhile (p * p <= n):\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * p, n+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn [p for p in range(2, n+1) if prime[p]]",
			"def pascal_triangle(n):\n\ttriangle = []\n\tfor i in range(n):\n\t\trow = [None for _ in range(i+1)]\n\t\trow[0], row[-1] = 1, 1\n\t\tfor j in range(1, len(row)-1):\n\t\t\trow[j] = triangle[i-1][j-1] + triangle[i-1][j]\n\t\ttriangle.append(row)\n\treturn triangle",
			"def next_palindrome(n):\n\tdef is_palindrome(n):\n\t\treturn str(n) == str(n)[::-1]\n\twhile not is_palindrome(n):\n\t\tn += 1\n\treturn n",
			"def multiply_polynomials(a, b):\n\tm, n = len(a), len(b)\n\tres = [0] * (m+n-1)\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tres[i+j] += a[i] * b[j]\n\treturn res",
			"def count_trailing_zeroes(n):\n\tcount = 0\n\ti = 5\n\twhile (n / i >= 1):\n\t\tcount += int(n / i)\n\t\ti *= 5\n\treturn count",
			"def bogo_sort(arr):\n\tdef is_sorted(arr):\n\t\tfor i in range(0, len(arr)-1):\n\t\t\tif arr[i] > arr[i+1]:\n\t\t\t\treturn False\n\t\treturn True\n\twhile not is_sorted(arr):\n\t\trand.shuffle(arr)\n\treturn arr",
			"def gcd(a, b):\n\twhile b:\n\t\ta, b = b, a % b\n\treturn a",
			"def rotate_matrix_90(matrix):\n\tn = len(matrix)\n\tfor layer in range(n // 2):\n\t\tfirst = layer\n\t\tlast = n - 1 - layer\n\t\tfor i in range(first, last):\n\t\t\toffset = i - first\n\t\t\ttop = matrix[first][i]\n\t\t\tmatrix[first][i] = matrix[last-offset][first]\n\t\t\tmatrix[last-offset][first] = matrix[last][last-offset]\n\t\t\tmatrix[last][last-offset] = matrix[i][last]\n\t\t\tmatrix[i][last] = top\n\treturn matrix",
			"def kadane_algorithm(nums):\n\tmax_current = max_global = nums[0]\n\tfor i in range(1, len(nums)):\n\t\tmax_current = max(nums[i], max_current + nums[i])\n\t\tif max_current > max_global:\n\t\t\tmax_global = max_current\n\treturn max_global"
		],
		"descriptions": [
			"Factorial: A mathematical algorithm that calculates the product of all positive integers less than or equal to a given positive integer. It's represented as n! and is foundational in combinatorics, algebra, and mathematical analysis.",
			"Reverse String: A simple algorithm that takes a string as input and reverses the order of characters in it. This operation is fundamental in string manipulation tasks and is often used to test the understanding of basic data structures like arrays and strings.",
			"Binary Search: An efficient algorithm for finding a target value within a sorted array. It compares the target value to the middle element of the array; if they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half until the target is found or the remaining half is empty.",
			"Bubble Sort: A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. Known for its simplicity but not suitable for large data sets.",
			"Quick Sort: An efficient, divide-and-conquer, comparison-based sorting algorithm. It picks an element as pivot and partitions the given array around the picked pivot. It's known for its better performance on large data sets, though its worst-case performance is less optimal.",
			"Binary Search: An efficient algorithm for finding a target value within a sorted array by repeatedly dividing in half the portion of the list that could contain the target, thus reducing the search area by half each time.",
			"Longest Increasing Subsequence: An algorithm to find the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order. This problem has applications in various fields such as bioinformatics, and computer animation.",
			"Longest Common Subsequence: A classic computer science problem to find the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.",
			"Minimum Cost Path: An algorithm that finds the path in a matrix (or grid) from a given source to a destination with the smallest possible cost, where cost is defined as the sum of the values of the cells along the path.",
			"Coin Change: A classic problem in dynamic programming that aims to find the minimum number of coins that make a particular amount of money, given an unlimited supply of coins of a set of denominations.",
			"Knap Sack: A problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.",
			"LPS: Longest Palindromic Subsequence problem involves finding the longest sequence of characters in a string that forms a palindrome. It is a variation of the Longest Common Subsequence problem.",
			"Is Multiple of Three?: An algorithm that determines whether a given number is a multiple of three, utilizing properties of numbers and often implemented using bit manipulation techniques for efficiency.",
			"Fibonacci: An algorithm for computing the nth Fibonacci number. Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1. It's a fundamental example in recursive programming and dynamic programming.",
			"Multiply: Refers to algorithms for multiplying numbers, possibly beyond the basic arithmetic operation, including algorithms for large numbers, matrix multiplication, or using specialized methods like the Karatsuba algorithm for efficiency.",
			"Square Root: An algorithm to find the square root of a number. This can involve various methods, including Newton's method (or the Newton-Raphson method), which is an iterative method for finding successively better approximations to the roots (or zeroes) of a real-valued function.",
			"Sieve of Eratosthenes: An ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking the multiples of each prime number starting from 2. The numbers that remain unmarked are prime.",
			"Pascal Triangle: An algorithm for generating Pascal's triangle, which is a triangular array of the binomial coefficients. It has applications in mathematics, computer science, and statistics.",
			"Next Palindrome: An algorithm to find the smallest palindrome larger than a given number. It's useful in fields such as cryptography and computational mathematics, where palindromic numbers have special properties.",
			"Multiply Polynomials: Refers to algorithms designed to multiply two polynomials, which is a foundational operation in algebra and has significant implications in computer science, particularly in algorithms related to signal processing and data analysis.",
			"Count Trailing Zeroes: An algorithm to count the number of trailing zeroes in the factorial of a given number. It is particularly useful in combinatorics and computational mathematics to estimate the size of large factorials without computing them directly.",
			"Bogo Sort: Also known as permutation sort, stupid sort, or slowsort, this is a highly ineffective sorting algorithm based on the generate and test paradigm. The algorithm successively generates permutations of its input until it finds one that is sorted. It is considered a humorous example of how not to design algorithms.",
			"Greatest Common Factor: An algorithm that finds the largest positive integer that divides each of the integers in a given set without leaving a remainder. It is a fundamental concept in number theory and is used in simplifying fractions and calculating ratios.",
			"Rotate Matrix 90: This algorithm rotates a matrix by 90 degrees in the clockwise direction without using any extra space. It is useful in image processing for tasks such as image rotation, and in scientific computing for matrix manipulation.",
			"Kadane Algorithm: A dynamic programming algorithm that finds the maximum sum subarray from a given array of integers. This subarray has the largest possible sum among all subarrays of the original array. Kadane's algorithm is widely used in computer science for solving array-based problems."
		]	
	}
}
