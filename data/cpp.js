const words = [
  "if",
  "for",
  "while",
  "switch",
  "case",
  "default",
  "break",
  "continue",
  "goto",
  "class",
  "struct",
  "union",
  "enum",
  "namespace",
  "template",
  "try",
  "catch",
  "throw",
  "new",
  "delete",
  "this",
  "nullptr",
  "true",
  "false",
  "using",
  "public",
  "private",
  "protected",
  "virtual",
  "override",
  "final",
  "const",
  "constexpr",
  "static",
  "extern",
  "inline",
  "dynamic_cast",
  "static_cast",
  "reinterpret_cast",
  "const_cast",
  "sizeof",
  "typeid",
  "friend",
  "operator",
  "auto",
  "decltype",
  "register",
  "volatile",
  "mutable",
  "explicit",
  "bool",
  "char",
  "wchar_t",
  "char16_t",
  "char32_t",
  "short",
  "int",
  "long",
  "float",
  "double",
  "void",
  "unsigned",
  "signed",
  "thread_local",
  "alignas",
  "alignof",
  "asm",
  "bitand",
  "bitor",
  "compl",
  "and",
  "or",
  "xor",
  "not",
  "and_eq",
  "or_eq",
  "xor_eq",
  "not_eq",
  "noexcept",
  "co_return",
  "co_yield",
  "co_await",
  "typeid",
  "template",
  "typename",
  "static_assert",
  "return",
  "main",
  "array",
  "vector",
  "map",
  "set",
  "pair",
  "list",
  "queue",
  "stack",
  "priority_queue",
  "bitset",
  "function",
  "tuple",
  "get",
  "make_pair",
  "emplace",
  "emplace_back",
  "push_back",
  "pop_back",
  "front",
  "back",
  "begin",
  "end",
  "rbegin",
  "rend",
  "find",
  "count",
  "erase",
  "insert",
  "iterator",
  "const_iterator",
  "reverse_iterator",
  "unique_ptr",
  "shared_ptr",
  "weak_ptr",
  "move",
  "forward",
  "bind",
  "function",
  "hash",
  "iostream",
  "fstream",
  "sstream",
  "cin",
  "cout",
  "cerr",
  "clog",
  "endl",
  "flush",
  "istream",
  "ostream",
  "ios_base",
  "std",
  "algorithm",
  "numeric",
  "utility",
  "iterator",
  "chrono",
  "functional",
  "memory",
  "limits",
  "exception",
  "stdexcept",
  "cassert",
  "type_traits",
  "initializer_list",
  "thread",
  "mutex",
  "future",
  "condition_variable",
  "random",
  "sstream",
  "iomanip",
  "filesystem"
];

const algorithms = [
  `int factorial(int n) {\n\tif (n == 0) return 1;\n\treturn n * factorial(n - 1);\n}`,
  `std::string reverse_string(const std::string& s) {\n\tint start_index = 0;\n\tint end_index = s.length() - 1;\n\tstd::string str = s;\n\twhile (start_index < end_index) {\n\t\tstd::swap(str[start_index], str[end_index]);\n\t\tstart_index++;\n\t\tend_index--;\n\t}\n\treturn str;\n}`,
  `int binary_search(const std::vector<int>& arr, int x) {\n\tint low = 0;\n\tint high = arr.size() - 1;\n\tint mid;\n\twhile (low <= high) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (arr[mid] < x) {\n\t\t\tlow = mid + 1;\n\t\t} else if (arr[mid] > x) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -1;\n}`,
  `std::string reverse_string(const std::string& s) {\n\tint start_index = 0;\n\tint end_index = s.length() - 1;\n\tstd::string str = s;\n\twhile (start_index < end_index) {\n\t\tstd::swap(str[start_index], str[end_index]);\n\t\tstart_index++;\n\t\tend_index--;\n\t}\n\treturn str;\n}`,
  `void bubble_sort(std::vector<int>& arr) {\n\tint n = arr.size();\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tfor (int j = 0; j < n - i - 1; ++j) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tstd::swap(arr[j], arr[j + 1]);\n\t\t\t}\n\t\t}\n\t}\n}`,
  `void quick_sort(std::vector<int>& arr) {\n\tif (arr.size() <= 1) return;\n\tint pivot = arr[arr.size() / 2];\n\tstd::vector<int> left;\n\tstd::vector<int> right;\n\tstd::vector<int> middle;\n\tfor (int i : arr) {\n\t\tif (i < pivot) left.push_back(i);\n\t\telse if (i == pivot) middle.push_back(i);\n\t\telse right.push_back(i);\n\t}\n\tquick_sort(left);\n\tquick_sort(right);\n\tarr.clear();\n\tarr.insert(arr.end(), left.begin(), left.end());\n\tarr.insert(arr.end(), middle.begin(), middle.end());\n\tarr.insert(arr.end(), right.begin(), right.end());\n}`,
];

export { words, algorithms };
